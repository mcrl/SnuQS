from functools import singledispatch

import braket.snuqs.quantumpy as qp
from braket.snuqs.operation import GateOperation


def from_braket_instruction(instruction) -> GateOperation:
    """Instantiates the concrete `GateOperation` object from the
    specified Braket instruction.

    Args:
        instruction: instruction for a circuit specified using the `braket.ir.jacqd` format.
    Returns:
        GateOperation]: instance of the concrete GateOperation or

    Raises:
        NotImplementedError: If no concrete `GateOperation` class has been
            registered for the instruction type.
    """
    return _from_braket_instruction(instruction)


@singledispatch
def _from_braket_instruction(instruction):
    raise NotImplementedError(f"Instruction {instruction} not recognized")


def check_matrix_dimensions(matrix: qp.ndarray, targets: tuple[int, ...]) -> None:
    """Checks that the matrix is of the correct shape to act on the targets.

    Args:
        matrix (qp.ndarray): The matrix to check
        targets (tuple[int, ...]): The target qubits the matrix acts on

    Raises:
        ValueError: If the matrix is not a square matrix or operates on a space
            of different dimension than that generated by the target qubits
    """
    if len(matrix.shape) != 2 or matrix.shape[0] != matrix.shape[1]:
        raise ValueError(f"{matrix} is not a two-dimensional square matrix")

    dimension = 2 ** len(targets)
    if dimension != matrix.shape[0]:
        raise ValueError(
            f"`matrix` operates on space of dimension {matrix.shape[0]} instead of {dimension}"
        )


def check_unitary(matrix: qp.ndarray):
    """Checks that the given matrix is unitary.

    Args:
        matrix (qp.ndarray): The matrix to check

    Raises:
        ValueError: If the matrix is not unitary
    """
    if not qp.allclose(qp.eye(len(matrix)), matrix.dot(matrix.T.conj())):
        raise ValueError(f"{matrix} is not unitary")


def check_hermitian(matrix: qp.ndarray):
    """Checks that the given matrix is Hermitian.

    Args:
        matrix (qp.ndarray): The matrix to check

    Raises:
        ValueError: If the matrix is not Hermitian
    """
    if not qp.allclose(matrix, matrix.T.conj()):
        raise ValueError(f"{matrix} is not Hermitian")


def ir_matrix_to_ndarray(matrix: list[list[list[float]]]) -> qp.ndarray:
    """Converts a JAQCD matrix into a numpy array.

    Args:
        matrix (list[list[list[float]]]: The IR representation of a matrix

    Returns:
        qp.ndarray: The numpy ndarray representation of the matrix
    """
    return qp.array([[complex(element[0], element[1]) for element in row] for row in matrix])


def check_cptp(matrices: list[qp.ndarray]):
    """Checks that the given matrices define a CPTP map.

    Args:
        matrices (list[qp.ndarray]): The matrices to check

    Raises:
        ValueError: If the matrices do not define a CPTP map
    """
    E = sum([qp.matmul(matrix.T.conjugate(), matrix) for matrix in matrices])
    if not qp.allclose(E, qp.eye(*E.shape)):
        raise ValueError(f"{matrices} do not define a CPTP map")
