from functools import singledispatch
from typing import Union

from braket.default_simulator.operation import GateOperation, KrausOperation


def from_braket_instruction(instruction) -> Union[GateOperation, KrausOperation]:
    """Instantiates the concrete `GateOperation` or `KrausOperation` object from the
    specified Braket instruction.

    Args:
        instruction: instruction for a circuit specified using the `braket.ir.jacqd` format.
    Returns:
        Union[GateOperation, KrausOperation]: instance of the concrete GateOperation or
        KrausOperation class corresponding to the specified instruction.

    Raises:
        NotImplementedError: If no concrete `GateOperation` or `KrausOperation` class has been
            registered for the instruction type.
    """
    return _from_braket_instruction(instruction)


@singledispatch
def _from_braket_instruction(instruction):
    raise NotImplementedError(f"Instruction {instruction} not recognized")


def check_matrix_dimensions(matrix: np.ndarray, targets: tuple[int, ...]) -> None:
    """Checks that the matrix is of the correct shape to act on the targets.

    Args:
        matrix (np.ndarray): The matrix to check
        targets (tuple[int, ...]): The target qubits the matrix acts on

    Raises:
        ValueError: If the matrix is not a square matrix or operates on a space
            of different dimension than that generated by the target qubits
    """
    if len(matrix.shape) != 2 or matrix.shape[0] != matrix.shape[1]:
        raise ValueError(f"{matrix} is not a two-dimensional square matrix")

    dimension = 2 ** len(targets)
    if dimension != matrix.shape[0]:
        raise ValueError(
            f"`matrix` operates on space of dimension {matrix.shape[0]} instead of {dimension}"
        )


def check_unitary(matrix: np.ndarray):
    """Checks that the given matrix is unitary.

    Args:
        matrix (np.ndarray): The matrix to check

    Raises:
        ValueError: If the matrix is not unitary
    """
    if not np.allclose(np.eye(len(matrix)), matrix.dot(matrix.T.conj())):
        raise ValueError(f"{matrix} is not unitary")


def ir_matrix_to_ndarray(matrix: list[list[list[float]]]) -> np.ndarray:
    """Converts a JAQCD matrix into a numpy array.

    Args:
        matrix (list[list[list[float]]]: The IR representation of a matrix

    Returns:
        np.ndarray: The numpy ndarray representation of the matrix
    """
    return np.array([[complex(element[0], element[1]) for element in row] for row in matrix])
